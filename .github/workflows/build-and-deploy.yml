name: build-and-deploy
on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    # ---- Everything we need pulled from Secrets you already created ----
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}          
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}      
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}    

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ---- ECR login (produces the registry URL) ----
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ---- Build & push (both a SHA tag and "latest") ----
      - name: Build and push image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}   # same as ECR_REGISTRY
          REPO: ${{ env.ECR_REPOSITORY }}
        run: |
          set -e
          SHA_TAG="$REGISTRY/$REPO:sha-${GITHUB_SHA}"
          LATEST_TAG="$REGISTRY/$REPO:latest"

          echo "Building $SHA_TAG and $LATEST_TAG ..."
          docker build -t "$SHA_TAG" -t "$LATEST_TAG" .

          echo "Pushing images ..."
          docker push "$SHA_TAG"
          docker push "$LATEST_TAG"

          # make the resolved image (sha tag) available to later steps
          echo "IMAGE=$SHA_TAG" >> $GITHUB_ENV

      # ---- Deploy on EC2 via SSM RunCommand (no SSH) ----
      - name: Deploy on EC2 (SSM)
        env:
          IMAGE: ${{ env.IMAGE }}                      # e.g. 123456....dkr.ecr.us-east-1.amazonaws.com/policy/compliance-system:sha-...
          EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail

          # Ensure jq is available (usually present, but just in case)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          echo "Deploying IMAGE=${IMAGE} to instance ${EC2_INSTANCE_ID} in ${AWS_REGION}"

          # Build the *exact* shell lines we want the instance to run
          CMDS=$(
            jq -Rc --slurp 'split("\n")[:-1]' <<'EOS'
      set -e
      cd ~/policy-qa
      touch .env
      if grep -q ^IMAGE= .env; then sed -i 's#^IMAGE=.*#IMAGE='"${IMAGE}"'#' .env; else echo IMAGE='"${IMAGE}"' >> .env; fi
      docker compose pull || true
      docker compose up -d
      docker image prune -f
      EOS
          )

          # Note: we *substitute* ${IMAGE} into the above here (after creating JSON safely)
          CMDS=$(echo "$CMDS" | sed "s|\${IMAGE}|${IMAGE}|g")

          # Kick off the SSM command
          CMD_ID=$(
            aws ssm send-command \
              --region "$AWS_REGION" \
              --instance-ids "$EC2_INSTANCE_ID" \
              --document-name "AWS-RunShellScript" \
              --comment "Policy QA deploy from GitHub Actions" \
              --parameters "commands=${CMDS}" \
              --timeout-seconds 600 \
              --query "Command.CommandId" \
              --output text
          )

          echo "SSM CommandId: $CMD_ID"

          # Wait for the command to execute
          aws ssm wait command-executed \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID"

          # Fetch detailed result
          INVOC=$(aws ssm get-command-invocation \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID" \
            --output json)

          STATUS=$(echo "$INVOC" | jq -r .Status)
          STDOUT=$(echo "$INVOC" | jq -r .StandardOutputContent)
          STDERR=$(echo "$INVOC" | jq -r .StandardErrorContent)

          echo "SSM Status: $STATUS"
          echo "----- STDOUT -----"
          printf "%s\n" "$STDOUT"
          echo "----- STDERR -----"
          printf "%s\n" "$STDERR"

          # Fail the job if SSM failed
          if [ "$STATUS" != "Success" ]; then
            echo "Deploy failed with status: $STATUS"
            exit 1
          fi