name: build-and-deploy
on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    # ---- Everything we need pulled from Secrets you already created ----
    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}          
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}      
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}    

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      # ---- ECR login (produces the registry URL) ----
      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      # ---- Build & push (both a SHA tag and "latest") ----
      - name: Build and push image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}   # same as ECR_REGISTRY
          REPO: ${{ env.ECR_REPOSITORY }}
        run: |
          set -e
          SHA_TAG="$REGISTRY/$REPO:sha-${GITHUB_SHA}"
          LATEST_TAG="$REGISTRY/$REPO:latest"

          echo "Building $SHA_TAG and $LATEST_TAG ..."
          docker build -t "$SHA_TAG" -t "$LATEST_TAG" .

          echo "Pushing images ..."
          docker push "$SHA_TAG"
          docker push "$LATEST_TAG"

          # make the resolved image (sha tag) available to later steps
          echo "IMAGE=$SHA_TAG" >> $GITHUB_ENV

      # ---- Deploy on EC2 via SSM RunCommand (no SSH) ----
      - name: Deploy on EC2 (SSM)
        shell: bash
        env:
          # IMAGE should have been set earlier in the job (the ECR image you just pushed)
          IMAGE: ${{ env.IMAGE }}
          EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}
          AWS_REGION: ${{ secrets.AWS_REGION }}
        run: |
          set -euo pipefail

          # Ensure jq is available on the runner
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          echo "Deploying IMAGE=${IMAGE} to instance ${EC2_INSTANCE_ID} (region ${AWS_REGION})"

          # The exact shell script you want the instance to execute
          # NOTE: we keep ${IMAGE} as a literal placeholder here and substitute below.
          read -r -d '' SCRIPT <<'SCRIPT_EOF'
      set -e
      cd ~/policy-qa
      touch .env
      if grep -q ^IMAGE= .env; then
        sed -i 's#^IMAGE=.*#IMAGE=${IMAGE}#' .env
      else
        echo "IMAGE=${IMAGE}" >> .env
      fi
      docker compose pull || true
      docker compose up -d
      docker image prune -f
      SCRIPT_EOF

          # Turn it into a JSON array of lines for SSM
          CMDS_JSON=$(jq -Rn --arg s "$SCRIPT" '$s|split("\n")')

          # Substitute the IMAGE value *after* JSON creation (safe)
          CMDS_JSON=${CMDS_JSON//'${IMAGE}'/"${IMAGE}"}

          # Send SSM command
          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Policy QA deploy from GitHub Actions" \
            --parameters "commands=${CMDS_JSON}" \
            --timeout-seconds 600 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: $CMD_ID"

          # Wait for completion and show logs
          aws ssm wait command-executed \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID"

          INVOC=$(aws ssm get-command-invocation \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID" \
            --output json)

          STATUS=$(echo "$INVOC" | jq -r .Status)
          echo "SSM Status: $STATUS"
          echo "----- STDOUT -----"
          echo "$INVOC" | jq -r .StandardOutputContent
          echo "----- STDERR -----"
          echo "$INVOC" | jq -r .StandardErrorContent

          test "$STATUS" = "Success"