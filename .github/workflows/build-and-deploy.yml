name: build-and-deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}          # e.g. 123456789012.dkr.ecr.us-east-1.amazonaws.com
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}      # e.g. policy/compliance-system
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}
          REPO: ${{ env.ECR_REPOSITORY }}
        run: |
          set -euo pipefail
          SHA_TAG="${REGISTRY}/${REPO}:sha-${GITHUB_SHA}"
          LATEST_TAG="${REGISTRY}/${REPO}:latest"

          echo "Building $SHA_TAG and $LATEST_TAG ..."
          docker build -t "$SHA_TAG" -t "$LATEST_TAG" .

          echo "Pushing images ..."
          docker push "$SHA_TAG"
          docker push "$LATEST_TAG"

          # export IMAGE for next steps
          echo "IMAGE=$SHA_TAG" >> "$GITHUB_ENV"

      - name: Deploy on EC2 via SSM
        env:
          IMAGE: ${{ env.IMAGE }}
          AWS_REGION: ${{ env.AWS_REGION }}
          EC2_INSTANCE_ID: ${{ env.EC2_INSTANCE_ID }}
        run: |
          set -euo pipefail

          # Ensure jq is available (used later to print logs nicely)
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          echo "Deploying IMAGE=${IMAGE} to EC2 instance ${EC2_INSTANCE_ID} (region ${AWS_REGION})"

          # 1) Write SSM parameters JSON to a file (no variable expansion here)
          cat > ssm-params.json <<'JSON'
          {
            "commands": [
              "set -e",
              "cd ~/policy-qa",
              "touch .env",
              "if grep -q ^IMAGE= .env; then sed -i 's#^IMAGE=.*#IMAGE=__IMAGE__#' .env; else echo IMAGE=__IMAGE__ >> .env; fi",
              "docker compose pull || true",
              "docker compose up -d",
              "docker image prune -f"
            ]
          }
          JSON

          # 2) Replace placeholder with real ECR image tag
          sed -i "s|__IMAGE__|${IMAGE}|g" ssm-params.json

          # 3) Send SSM command using the JSON file
          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Policy QA deploy from GitHub Actions" \
            --parameters file://ssm-params.json \
            --timeout-seconds 600 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: $CMD_ID"

          # 4) Wait for completion and print logs
          aws ssm wait command-executed \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID"

          INVOC=$(aws ssm get-command-invocation \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID" \
            --output json)

          STATUS=$(echo "$INVOC" | jq -r .Status)
          echo "SSM Status: $STATUS"
          echo "----- STDOUT -----"
          echo "$INVOC" | jq -r .StandardOutputContent
          echo "----- STDERR -----"
          echo "$INVOC" | jq -r .StandardErrorContent

          test "$STATUS" = "Success"