name: build-and-deploy

on:
  push:
    branches: [ main ]
  workflow_dispatch: {}

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      id-token: write
      contents: read

    env:
      AWS_REGION: ${{ secrets.AWS_REGION }}
      ECR_REGISTRY: ${{ secrets.ECR_REGISTRY }}          # e.g. 123456789012.dkr.ecr.us-east-1.amazonaws.com
      ECR_REPOSITORY: ${{ secrets.ECR_REPOSITORY }}      # e.g. policy/compliance-system
      EC2_INSTANCE_ID: ${{ secrets.EC2_INSTANCE_ID }}

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ env.AWS_REGION }}

      - name: Login to Amazon ECR
        id: login-ecr
        uses: aws-actions/amazon-ecr-login@v2

      - name: Build and push image
        env:
          REGISTRY: ${{ steps.login-ecr.outputs.registry }}   # usually the same as ECR_REGISTRY
          REPO: ${{ env.ECR_REPOSITORY }}
        run: |
          set -euo pipefail
          SHA_TAG="${REGISTRY}/${REPO}:sha-${GITHUB_SHA}"
          LATEST_TAG="${REGISTRY}/${REPO}:latest"

          echo "Building $SHA_TAG and $LATEST_TAG ..."
          docker build -t "$SHA_TAG" -t "$LATEST_TAG" .

          echo "Pushing images ..."
          docker push "$SHA_TAG"
          docker push "$LATEST_TAG"

          # make the resolved image available to next step
          echo "IMAGE=$SHA_TAG" >> "$GITHUB_ENV"

      - name: Deploy on EC2 (SSM)
        shell: bash
        env:
          IMAGE: ${{ env.IMAGE }}                # comes from previous step (GITHUB_ENV)
          AWS_REGION: ${{ env.AWS_REGION }}
          EC2_INSTANCE_ID: ${{ env.EC2_INSTANCE_ID }}
        run: |
          set -euo pipefail

          # Ensure jq is present
          if ! command -v jq >/dev/null 2>&1; then
            sudo apt-get update -y
            sudo apt-get install -y jq
          fi

          echo "Deploying IMAGE=${IMAGE} to instance ${EC2_INSTANCE_ID} (region ${AWS_REGION})"

          # Build the exact remote script (keep ${IMAGE} literal here)
          read -r -d '' SCRIPT <<'SCRIPT_EOF'
set -e
cd ~/policy-qa
touch .env
if grep -q ^IMAGE= .env; then
  sed -i 's#^IMAGE=.*#IMAGE=${IMAGE}#' .env
else
  echo "IMAGE=${IMAGE}" >> .env
fi
docker compose pull || true
docker compose up -d
docker image prune -f
SCRIPT_EOF

          # Convert to SSM JSON (array of lines), then substitute IMAGE safely
          CMDS_JSON=$(jq -Rn --arg s "$SCRIPT" '$s|split("\n")')
          CMDS_JSON=${CMDS_JSON//'${IMAGE}'/"${IMAGE}"}

          # Send SSM command
          CMD_ID=$(aws ssm send-command \
            --region "$AWS_REGION" \
            --instance-ids "$EC2_INSTANCE_ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Policy QA deploy from GitHub Actions" \
            --parameters "commands=${CMDS_JSON}" \
            --timeout-seconds 600 \
            --query "Command.CommandId" \
            --output text)

          echo "SSM CommandId: $CMD_ID"

          # Wait and print logs
          aws ssm wait command-executed \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID"

          INVOC=$(aws ssm get-command-invocation \
            --region "$AWS_REGION" \
            --command-id "$CMD_ID" \
            --instance-id "$EC2_INSTANCE_ID" \
            --output json)

          STATUS=$(echo "$INVOC" | jq -r .Status)
          echo "SSM Status: $STATUS"
          echo "----- STDOUT -----"
          echo "$INVOC" | jq -r .StandardOutputContent
          echo "----- STDERR -----"
          echo "$INVOC" | jq -r .StandardErrorContent

          test "$STATUS" = "Success"